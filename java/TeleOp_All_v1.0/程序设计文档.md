# FTC32477 车辆控制程序设计文档

## 概述
这是基于FTC "Decode" 赛季的麦克纳姆轮小车控制程序，采用 TeleOp（远程操控）模式，通过 Xbox 手柄控制车辆的底盘移动和各个子系统（拾取、装填、发射）。

---

## 程序架构

### 类结构
- **主类**: `FTC32477` 继承自 `LinearOpMode`
- **执行入口**: `runOpMode()` 方法（第77-110行）

### 硬件组件列表

| 组件分类 | 设备名称 | 数量 | 说明 |
|---------|--------|------|------|
| **底盘电机** | frontLeft(lf) | 1 | 前左麦克纳姆轮 |
|  | frontRight(rf) | 1 | 前右麦克纳姆轮 |
|  | backLeft(lb) | 1 | 后左麦克纳姆轮 |
|  | backRight(rb) | 1 | 后右麦克纳姆轮 |
| **拾取系统** | intake | 1 | 拾取模块电机 |
| **装填系统** | load | 1 | 装填/压膛电机 |
| **发射系统** | s1, s2 | 2 | 双电机闭环控制 |

---

## 控制逻辑详解

### 1. 程序初始化阶段（第115-185行）
**`initializeHardware()` 方法**

#### 功能：
- 获取硬件设备引用（通过 `hardwareMap` 映射到实际电机）
- 设置各电机方向：
  - 前左：正向，前右：反向，后左：反向，后右：正向
  - 拾取：正向
  - 装填：反向
  - 发射 s1：反向，s2：正向
- 设置运行模式为 `RUN_WITHOUT_ENCODER`（无编码器反馈）
- 发射电机零功率行为设为 `BRAKE`（制动）
- 初始化所有电机功率为 0

**关键代码段** (第140-165行)：
```java
frontLeft.setDirection(DcMotorSimple.Direction.FORWARD);
frontRight.setDirection(DcMotorSimple.Direction.REVERSE);
backLeft.setDirection(DcMotorSimple.Direction.REVERSE);
backRight.setDirection(DcMotorSimple.Direction.FORWARD);
```

### 2. 主控制循环（第85-110行）

程序在 `while(opModeIsActive())` 循环内执行，整个流程分为5个步骤：

```
┌─────────────────────────────────────┐
│   处理映射模式切换 (Y键)             │
│   handleMappingModeToggle()          │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│   读取摇杆/扳机输入                  │
│   drive, strafe, turn               │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│   应用非线性映射（可选）             │
│   applyNonlinearMapping()            │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│   麦克纳姆轮运动学计算               │
│   calculateMecanumDrive()            │
│   输出四轮功率                       │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│   设置电机功率                       │
│   setMotorPowers()                   │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│   处理子系统控制                     │
│   handleSubsystemControls()          │
│   (LT/RT/A/B 按键)                   │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│   处理发射速度调节                   │
│   handleShooterSpeedAdjustment()     │
│   (D-Pad 上/下)                      │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│   更新遥测信息显示                   │
│   displayTelemetry()                 │
└─────────────────────────────────────┘
```

---

## 详细模块说明

### 模块1：摇杆输入处理（第85-92行）

```java
double drive = -gamepad1.left_stick_y;      // 前后（Z轴负向）
double strafe = gamepad1.left_stick_x;      // 左右
double turn = gamepad1.right_stick_x * 0.8; // 旋转（衰减80%）
```

**输入映射**：
- 左摇杆 Y 轴（-1 到 1）→ 前后移动（取反是因为游杆向前为负）
- 左摇杆 X 轴（-1 到 1）→ 左右平移
- 右摇杆 X 轴（-1 到 1）→ 原地旋转（乘以 0.8 降低灵敏度）

### 模块2：非线性映射（第93-96行 + 第317-325行）

**方法**: `applyNonlinearMapping()`

```java
double sign = value > 0 ? 1.0 : -1.0;
return sign * value * value;  // 平方映射
```

**作用**：
- 启用状态：小幅度摇杆操作更精确，大幅度保持最大值
- 禁用状态：线性响应，摇杆值直接映射到功率
- 切换方式：Y 键（边沿检测）

**示例**：
| 输入 | 线性映射 | 非线性映射 |
|------|--------|----------|
| 0.2 | 0.2 | 0.04 |
| 0.5 | 0.5 | 0.25 |
| 1.0 | 1.0 | 1.0 |

### 模块3：麦克纳姆轮运动学（第207-242行）

**方法**: `calculateMecanumDrive()`

#### 原理
麦克纳姆轮是一种全向轮，可同时实现前进、侧移、旋转。四轮功率计算：

```
LF = drive + strafe + turn    (左前)
RF = drive - strafe - turn    (右前)
LB = drive - strafe + turn    (左后)
RB = drive + strafe - turn    (右后)
```

#### 关键步骤：

1. **应用死区** (第213-216行)
   ```java
   drive = applyDeadzone(drive);
   strafe = applyDeadzone(strafe);
   turn = applyDeadzone(turn);
   ```
   死区阈值：0.1（摇杆漂移防护）

2. **计算原始功率** (第218-221行)
   ```java
   double leftFrontPower  = drive + strafe + turn;
   double rightFrontPower = drive - strafe - turn;
   double leftBackPower   = drive - strafe + turn;
   double rightBackPower  = drive + strafe - turn;
   ```

3. **归一化功率** (第223-232行)
   - 若任一轮功率超过 1.0，则等比缩放所有轮功率
   - 保持运动方向不变，降低幅度

4. **应用功率限制** (第234-239行)
   - 乘以 `MAX_POWER` (1.0)，确保安全

#### 物理补偿
注释提及："后两个轮子物理安装方向不同，在运动学公式中直接补偿"
- 这通过硬件初始化中的电机方向设置实现
- 前左右为一种旋转方向，后左右相反

### 模块4：底盘电机驱动（第289-294行）

**方法**: `setMotorPowers()`

```java
frontLeft.setPower(wheelPowers[0]);
frontRight.setPower(wheelPowers[1]);
backLeft.setPower(wheelPowers[2]);
backRight.setPower(wheelPowers[3]);
```

直接将计算出的四轮功率写入对应电机。

---

## 子系统控制

### 模块5：子系统按键映射（第267-287行）

**方法**: `handleSubsystemControls()`

| 按键/扳机 | 功能 | 条件 | 动作 |
|---------|------|------|------|
| LT (左扳机) | 装填 | 扳机值 > 0.1 | load 电机 +100% 功率 |
| RT (右扳机) | 发射 | 扳机值 > 0.1 | s1 +100%, s2 -100% |
| A 键 | 拾取正向 | 按下 | intake +100% |
| B 键 | 拾取反向 | 按下 | intake -100% |
| 未定义 | 其他 | 无 | 对应电机功率 = 0 |

**代码逻辑**：
```java
if (gamepad1.left_trigger > DEADZONE) {
    load.setPower(1.0);
} else {
    load.setPower(0);
}
```

### 模块6：发射速度调节（第245-254行）

**方法**: `handleShooterSpeedAdjustment()`

- **D-Pad 上**: 目标 RPM +50
- **D-Pad 下**: 目标 RPM -50
- **边沿检测**: 只在按键按下瞬间改变，防止连续增减
- **范围限制**: 使用 `Range.clip()` 确保 RPM 在合法范围内

```java
if (up && !prevDpadUp) {  // 边沿检测
    TARGET_RPM = Range.clip(TARGET_RPM + SHOOTER_SPEED_STEP, 0.0, 1.0);
}
prevDpadUp = up;  // 保存此次状态
```

**关键参数**：
- `SHOOTER_SPEED_STEP = 50` (RPM)
- `TARGET_RPM = 1500` (初始值)

### 模块7：映射模式切换（第256-262行）

**方法**: `handleMappingModeToggle()`

- Y 键切换线性/非线性映射模式
- 同样采用边沿检测，防止高频抖动
- 影响范围：仅影响左摇杆 (drive, strafe)，不影响右摇杆 (turn)

---

## 闭环控制系统（发射模块）

### 硬件配置（第60-69行）

```java
private DcMotorEx s1;
private DcMotorEx s2;
```

使用 `DcMotorEx` 而非普通 `DcMotor`，支持扩展功能（如速度反馈）。

### PID 参数（第72-76行）

```java
public static final double MOTOR_TICK_COUNT = 28;  // 编码器刻度
public static double P = 135, I = 0, D = 80, F = 14;
public static double TARGET_RPM = 1500;
public static int ErrorRange = 50;
```

**说明**：
- `MOTOR_TICK_COUNT = 28`: 每转一圈的编码器刻度数
- `P = 135`: 比例系数（较大，快速响应）
- `I = 0`: 积分系数（未使用）
- `D = 80`: 微分系数（阻尼，防止超调）
- `F = 14`: 前馈系数（补偿固定的机械阻力）
- `ErrorRange = 50`: 认为达到目标速度的误差容限

### 速度显示（第381-382行）

```java
double currentRPM = (s1.getVelocity() / MOTOR_TICK_COUNT) * 60;
```

- 读取 s1 电机速度（rad/s）
- 转换为 RPM：先除以刻度数得圈数，再乘以 60

---

## 死区和功率限制

### 死区（第338-342行）

**方法**: `applyDeadzone()`

```java
private static final double DEADZONE = 0.1;

if (Math.abs(value) < DEADZONE) {
    return 0.0;
}
```

**作用**：
- 摇杆漂移防护
- 阈值 0.1：小于此值的输入被视为 0
- 应用位置：
  - 底盘摇杆 (drive, strafe, turn) —— 第213-216行
  - LT/RT 扳机 —— 第272, 279 行

### 功率限制（第63-64行）

```java
private static final double MAX_POWER = 1.0;
```

- 最大电机功率限制为 100%
- 在运动学计算的归一化后再应用

---

## 遥测信息显示（第385-407行）

**方法**: `displayTelemetry()`

向驾驶员实时显示：
1. **控制模式**: 当前是线性/非线性映射
2. **发射模块**: 
   - 状态（发射中/提速中/关闭）
   - 目标/当前 RPM
3. **装填模块**: 当前功率
4. **拾取模块**: 当前功率
5. **底盘电机**: 四轮功率
6. **按键说明**: 快速参考

---

## 数据流总图

```
游戏手柄输入
    ↓
┌─────────────────────────────────┐
│  左摇杆 (drive, strafe)          │
│  右摇杆 (turn)                   │
│  LT/RT/A/B (子系统)              │
│  D-Pad 上/下 (速度微调)          │
│  Y键 (模式切换)                  │
└────────────┬────────────────────┘
             ↓
┌─────────────────────────────────┐
│  应用死区 (DEADZONE=0.1)        │
└────────────┬────────────────────┘
             ↓
     ┌───────┴────────┐
     ↓                ↓
┌─────────────┐  ┌──────────────┐
│  左摇杆     │  │  子系统/速度 │
│  应用非线性 │  │  直接赋值    │
│  映射       │  │              │
└─────┬───────┘  └──────┬───────┘
      ↓                 ↓
┌─────────────────────────────────┐
│  运动学计算 (麦克纳姆轮公式)    │
│  FL/FR/BL/BR 功率               │
└────────────┬────────────────────┘
             ↓
┌─────────────────────────────────┐
│  归一化 (若超过 1.0)             │
│  应用功率限制 (MAX_POWER=1.0)    │
└────────────┬────────────────────┘
             ↓
┌─────────────────────────────────┐
│  写入硬件                        │
│  • 四个底盘电机                  │
│  • intake/load/s1/s2             │
└────────────┬────────────────────┘
             ↓
┌─────────────────────────────────┐
│  遥测显示 + 反馈循环             │
└─────────────────────────────────┘
```

---

## 关键设计决策

| 决策 | 原因 |
|------|------|
| **非线性映射(平方)** | 提高精确度：小操作更精细，大操作保持最大响应 |
| **扳机死区 0.1** | 模拟器/硬件的扳机抖动容限 |
| **归一化计算** | 防止任一轮超速，导致电机烧损 |
| **发射电机反向** | 符合机械设计（双轮相向旋转增加压力） |
| **边沿检测** | 防止快速重复触发（如连续增减转速） |
| **PID 参数** | P(135) 大：快速追赶 / D(80) 大：阻尼防超调 |
| **零功率为 BRAKE** | 防止发射轮在停止时被反向推动 |

---

## 可能的扩展点

程序注释中提及的未实现功能：
1. **预设转速**: 不同场地位置的固定发射速度（如"超远""三角腰"）
2. **自动转向**: IMU 辅助的精准角度旋转
3. **其他子系统**: 爪子、挡板等额外执行器

这些功能可以通过添加新按键绑定和对应的处理方法实现。

---

## 总结

这是一个**功能完整的 TeleOp 竞赛程序**，具有：
- ✅ 全向底盘控制（麦克纳姆轮）
- ✅ 三个独立子系统（拾取/装填/发射）
- ✅ 发射速度实时调节
- ✅ 控制灵敏度可调（线性/非线性切换）
- ✅ 完善的死区和功率限制（安全性）
- ✅ 实时反馈和状态显示

程序逻辑清晰，安全机制完整，适合比赛场景使用。
